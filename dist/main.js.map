{"version":3,"file":"main.js","sources":["../src/engine/events/constants.ts","../src/engine/events/implementation.ts","../src/engine/state/implementation.ts","../src/store/signal/implementation.ts","../src/store/slice/middlewares/local_storage_middleware.ts","../src/store/slice/middlewares/session_storage_middleware.ts","../src/store/slice/implementation.ts","../src/store/storage/implementation.ts","../src/tools/effect/implementation.ts","../src/tools/computed/implementation.ts","../src/tools/selector/implementation.ts","../src/utils/is.ts"],"sourcesContent":["export const LISTENING_PREFIX = 'listening:';\r\n","import { LISTENING_PREFIX } from './constants';\r\nimport { EventEngine, EventEngineDefaults, EventEngineState, Events, ListenOptions } from './types';\r\n\r\nexport function event_engine<E extends Events>(defaults?: EventEngineDefaults) {\r\n  const state: EventEngineState<E> = {};\r\n\r\n  const get = <K extends keyof E>(type: K) => {\r\n    return (state[type] ??= { listeners: [] });\r\n  };\r\n\r\n  function fire<K extends keyof E & string>(type: K, next: E[K]) {\r\n    const subscription = get(type);\r\n    subscription.listeners.forEach((listener) => {\r\n      listener(next, subscription.previous);\r\n    });\r\n    subscription.previous = next;\r\n  }\r\n\r\n  function listen<K extends keyof E & string>(options: ListenOptions<K, E[K], E[K]>) {\r\n    const { type, select, each, once } = options;\r\n    const equal = options.equal ?? defaults?.equal;\r\n\r\n    const subscription = get(type);\r\n\r\n    function clear() {\r\n      const { listeners } = subscription;\r\n\r\n      const index = listeners.indexOf(listener);\r\n      if (index === -1) {\r\n        console.warn('event engine: registered listener not found');\r\n        return;\r\n      }\r\n\r\n      listeners.splice(index, 1);\r\n    }\r\n\r\n    function listener(next: E[K], old: E[K] | undefined) {\r\n      try {\r\n        if (select) {\r\n          next &&= select(next);\r\n          old &&= select(old);\r\n        }\r\n\r\n        if (old && equal?.(next, old)) return;\r\n\r\n        if (each) {\r\n          each(next);\r\n        } else if (once) {\r\n          once(next);\r\n          clear();\r\n        } else {\r\n          console.error('event engine: no listener was provided');\r\n        }\r\n      } catch (error) {\r\n        console.error(error);\r\n      }\r\n    }\r\n\r\n    subscription.listeners.push(listener);\r\n\r\n    if (!type.startsWith(LISTENING_PREFIX)) {\r\n      // @ts-expect-error\r\n      fire(LISTENING_PREFIX + type, listener);\r\n    }\r\n\r\n    return clear;\r\n  }\r\n\r\n  return { fire, listen } as EventEngine<E>;\r\n}\r\n","import { StateEngine } from './types';\r\n\r\nexport function state_engine<T>(): StateEngine<T | undefined>;\r\nexport function state_engine<T>(initial: T): StateEngine<T>;\r\nexport function state_engine<T>(initial?: T) {\r\n  const state = { current: initial, previous: initial };\r\n\r\n  function get(previous?: boolean) {\r\n    return previous ? state.previous : state.current;\r\n  }\r\n\r\n  function set(value: T): void {\r\n    state.previous = state.current;\r\n    state.current = value;\r\n  }\r\n\r\n  return { get, set };\r\n}\r\n","import { is_not_null, is_null, struct, unpack } from '@nagisham/standard';\r\n\r\nimport { event_engine, state_engine } from 'src/engine';\r\n\r\nimport { StoreEvents, WithPrevious } from '../types';\r\nimport { SignalStruct } from './types';\r\n\r\nexport const signal = struct<SignalStruct>(<T>(initial?: T) => {\r\n  const { get, set } = state_engine(initial);\r\n  const { fire, listen } = event_engine<StoreEvents<T | undefined>>();\r\n\r\n  listen({\r\n    type: 'listening:change',\r\n    each: (listener) => {\r\n      is_not_null(get()) && listener(get());\r\n    },\r\n  });\r\n\r\n  listen({\r\n    type: 'cleanup',\r\n    each: () => set(undefined),\r\n  });\r\n\r\n  function accesser(value?: T | WithPrevious<T | undefined>) {\r\n    if (is_null(value)) {\r\n      return get();\r\n    }\r\n\r\n    const old = get();\r\n    const next = unpack(value, old);\r\n\r\n    if (!Object.is(old, next)) {\r\n      set(next);\r\n      fire('change', next);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  return Object.assign(accesser, { fire, listen });\r\n});\r\n","import { is_not_null } from '@nagisham/standard';\r\n\r\nimport { Middleware } from '../types';\r\n\r\nexport function local_storage_middleware(key: string): Middleware {\r\n  return ({ set, listen }) => {\r\n    const initial = localStorage.getItem(key);\r\n\r\n    if (is_not_null(initial)) {\r\n      set(JSON.parse(initial));\r\n    }\r\n\r\n    listen({\r\n      type: 'change',\r\n      each: (next) => {\r\n        localStorage.setItem(key, JSON.stringify(next));\r\n      },\r\n    });\r\n  };\r\n}\r\n","import { is_not_null } from '@nagisham/standard';\r\n\r\nimport { Middleware } from '../types';\r\n\r\nexport function session_storage_middleware(key: string): Middleware {\r\n  return ({ set, listen }) => {\r\n    const initial = sessionStorage.getItem(key);\r\n\r\n    if (is_not_null(initial)) {\r\n      set(JSON.parse(initial));\r\n    }\r\n\r\n    listen({\r\n      type: 'change',\r\n      each: (next) => {\r\n        sessionStorage.setItem(key, JSON.stringify(next));\r\n      },\r\n    });\r\n  };\r\n}\r\n","import {\r\n  is_function,\r\n  is_not_null,\r\n  is_null,\r\n  is_object,\r\n  is_string,\r\n  struct,\r\n  unpack,\r\n} from '@nagisham/standard';\r\n\r\nimport { event_engine, state_engine } from 'src/engine';\r\n\r\nimport { State, StoreEvents, WithPrevious } from '../types';\r\nimport { Middleware, SliceStruct } from './types';\r\n\r\nexport const slice = struct<SliceStruct>(\r\n  <T extends State>(initial?: T, middlewares?: Middleware[]) => {\r\n    const state = state_engine(initial);\r\n    const events = event_engine<StoreEvents<T | undefined>>();\r\n\r\n    events.listen({\r\n      type: 'listening:change',\r\n      each: (listener) => {\r\n        is_not_null(state.get()) && listener(state.get());\r\n      },\r\n    });\r\n\r\n    events.listen({\r\n      type: 'cleanup',\r\n      each: () => state.set(undefined),\r\n    });\r\n\r\n    function copy() {\r\n      return Object.assign({}, state.get());\r\n    }\r\n\r\n    function accesser<K extends keyof T>(\r\n      key_value?: K | Partial<T> | WithPrevious<Partial<T> | undefined>,\r\n      value?: T[K] | WithPrevious<T[K] | undefined>,\r\n    ) {\r\n      if (is_null(key_value) && is_null(value)) {\r\n        return copy();\r\n      }\r\n\r\n      if (is_object(key_value) || is_function(key_value)) {\r\n        const old = state.get();\r\n        const next = Object.assign({}, old, unpack(key_value, old));\r\n\r\n        state.set(next);\r\n        events.fire('change', next);\r\n      }\r\n\r\n      if (is_string(key_value) && is_null(value)) {\r\n        return state.get()?.[key_value];\r\n      }\r\n\r\n      if (is_string(key_value) && is_not_null(value)) {\r\n        const old = state.get();\r\n        const next = Object.assign({}, old, {\r\n          [key_value]: unpack(value, old?.[key_value]),\r\n        });\r\n\r\n        state.set(next);\r\n        events.fire('change', next);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    middlewares?.forEach((middleware) => {\r\n      middleware({ ...state, ...events });\r\n    });\r\n\r\n    return Object.assign(accesser, events);\r\n  },\r\n);\r\n","import {\r\n  Lambda,\r\n  is_array,\r\n  is_function,\r\n  is_not_null,\r\n  is_null,\r\n  is_string,\r\n  struct,\r\n  unpack,\r\n} from '@nagisham/standard';\r\n\r\nimport { event_engine, state_engine } from 'src/engine';\r\n\r\nimport { StoreEvents, WithPrevious } from '../types';\r\nimport { ArrayEvents, StorageStruct } from './types';\r\n\r\nexport const storage = struct<StorageStruct>(<T>(elements?: T[]) => {\r\n  const { get, set } = state_engine(elements ?? []);\r\n  const { fire, listen } = event_engine<StoreEvents<T[]> & ArrayEvents<T | undefined>>();\r\n\r\n  listen({\r\n    type: 'listening:change',\r\n    each: (listener) => {\r\n      get().length && listener(copy());\r\n    },\r\n  });\r\n\r\n  listen({\r\n    type: 'cleanup',\r\n    each: () => set([]),\r\n  });\r\n\r\n  function copy(previous?: boolean) {\r\n    return get(previous).slice();\r\n  }\r\n\r\n  function accesser(\r\n    index_value?: number | string | T[] | WithPrevious<T[]>,\r\n    value?: T | WithPrevious<T | undefined> | undefined,\r\n  ) {\r\n    if (is_null(index_value) && is_null(value)) {\r\n      return copy();\r\n    }\r\n\r\n    if (is_array(index_value) || is_function(index_value)) {\r\n      const next = unpack(index_value, copy());\r\n      set(next);\r\n      fire('change', next);\r\n      return;\r\n    }\r\n\r\n    if (is_not_null(index_value)) {\r\n      const index = is_string(index_value) ? parseInt(index_value) : index_value;\r\n\r\n      if (is_null(value)) {\r\n        return get()[index];\r\n      }\r\n\r\n      const old = get()[index];\r\n      insert(index, unpack(value, old));\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  function find(predicate: Lambda<[T], boolean>) {\r\n    return get().findIndex(predicate);\r\n  }\r\n\r\n  function insert(item: T): void;\r\n  function insert(index: number, item: T): void;\r\n  function insert(index_item: number | T, item?: T) {\r\n    const array = copy();\r\n\r\n    let index: number;\r\n    let element: T;\r\n\r\n    if (is_null(item)) {\r\n      index = array.length;\r\n      element = index_item as T;\r\n    } else {\r\n      index = index_item as number;\r\n      element = item;\r\n    }\r\n\r\n    array.splice(index, 0, element);\r\n\r\n    set(array);\r\n    fire('insert', { index, element });\r\n  }\r\n\r\n  function remove(index: number) {\r\n    const array = copy();\r\n\r\n    const element = array.splice(index, 1)[0];\r\n\r\n    set(array);\r\n    fire('remove', { index, element });\r\n\r\n    return element;\r\n  }\r\n\r\n  function len(): number;\r\n  function len(index: number): void;\r\n  function len(index?: number) {\r\n    const array = get();\r\n\r\n    if (is_null(index)) {\r\n      return array.length;\r\n    }\r\n\r\n    if (index === 0) {\r\n      fire('cleanup');\r\n      return;\r\n    }\r\n\r\n    let i = array.length;\r\n    while (i > index) {\r\n      i--;\r\n      remove(i);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  function each(action: Lambda<[T, number], void>) {\r\n    get().forEach(action);\r\n  }\r\n\r\n  return Object.assign(accesser, {\r\n    find,\r\n    insert,\r\n    remove,\r\n    len,\r\n    each,\r\n    fire,\r\n    listen,\r\n  });\r\n});\r\n","import { Functions, is_function, is_not_null } from '@nagisham/standard';\r\n\r\nimport { Signal } from 'src/store';\r\nimport { ListenOptions } from 'src/engine';\r\n\r\nimport { Cleanup, Effect, EffectOptions } from './types';\r\n\r\nexport const effect: Effect = (options: EffectOptions<Signal[]>): Cleanup => {\r\n  const { listener, dependency } = options;\r\n\r\n  const unsubscribe = new Array<Cleanup>();\r\n  let cleanup: void | Cleanup;\r\n\r\n  const listen_options: ListenOptions<'change', unknown, unknown> = {\r\n    type: 'change',\r\n    each: () => {},\r\n  };\r\n\r\n  dependency.forEach((signal) => {\r\n    listen_options.each = () => {\r\n      if (is_function(cleanup)) {\r\n        cleanup();\r\n        cleanup = undefined;\r\n      }\r\n\r\n      const args = dependency.map(Functions.call);\r\n      if (args.every(is_not_null)) {\r\n        cleanup = listener(...args);\r\n      }\r\n    };\r\n\r\n    unsubscribe.push(signal.listen(listen_options));\r\n  });\r\n\r\n  return () => unsubscribe.forEach(Functions.call);\r\n};\r\n","import { signal } from 'src/store';\r\n\r\nimport { effect } from '../effect';\r\nimport { Computed, ComputedOptions } from './types';\r\n\r\nexport const computed: Computed = <T>(options: ComputedOptions<T, [any]>) => {\r\n  const { listener, dependency } = options;\r\n\r\n  const computed_signal = signal<T>();\r\n\r\n  effect({\r\n    listener: (...args) => {\r\n      computed_signal(listener(...args));\r\n    },\r\n    dependency,\r\n  });\r\n\r\n  return computed_signal;\r\n};\r\n","import { combine } from '@nagisham/standard';\r\n\r\nimport { signal, Signal, Slice } from 'src/store';\r\nimport { State } from 'src/store/types';\r\n\r\nexport function selector<S extends State, T extends S[keyof S]>(\r\n  slice: Slice<S>,\r\n  select: (state: S) => T,\r\n): Signal<T> {\r\n  type K = keyof S & string;\r\n\r\n  const state = {} as { key: K };\r\n\r\n  const proxy = new Proxy(slice(), {\r\n    get: (target, key: K) => {\r\n      state.key = key;\r\n      return Reflect.get(target, key);\r\n    },\r\n  });\r\n\r\n  const selector = signal(select(proxy));\r\n\r\n  selector.listen({\r\n    type: 'cleanup',\r\n    once: combine(\r\n      slice.listen({\r\n        type: 'change',\r\n        select,\r\n        each: (next) => {\r\n          selector(next);\r\n        },\r\n      }),\r\n      selector.listen({\r\n        type: 'change',\r\n        each: (next) => {\r\n          slice(state.key, next);\r\n        },\r\n      }),\r\n    ),\r\n  });\r\n\r\n  return selector;\r\n}\r\n","import { Signal, Slice, State, Storage, signal, slice, storage } from 'src/store';\r\n\r\nexport function is_signal<A, T>(object: A | Signal<T>): object is Signal<T> {\r\n  return object instanceof signal;\r\n}\r\n\r\nexport function is_slice<A, T extends State | undefined>(object: A | Slice<T>): object is Slice<T> {\r\n  return object instanceof slice;\r\n}\r\n\r\nexport function is_storage<A, T>(object: A | Storage<T>): object is Storage<T> {\r\n  return object instanceof storage;\r\n}\r\n"],"names":["LISTENING_PREFIX","event_engine","defaults","state","get","type","fire","next","subscription","listener","listen","options","select","each","once","equal","clear","listeners","index","old","error","state_engine","initial","previous","set","value","signal","struct","is_not_null","accesser","is_null","unpack","local_storage_middleware","key","session_storage_middleware","slice","middlewares","events","copy","key_value","is_object","is_function","is_string","_a","middleware","storage","elements","index_value","is_array","insert","find","predicate","index_item","item","array","element","remove","len","i","action","effect","dependency","unsubscribe","cleanup","listen_options","args","Functions","computed","computed_signal","selector","proxy","target","combine","is_signal","object","is_slice","is_storage"],"mappings":"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"}