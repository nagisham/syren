{"version":3,"file":"main.cjs","sources":["../src/engine/events/constants.ts","../src/engine/events/implementation.ts","../src/engine/state/implementation.ts","../src/store/signal/implementation.ts","../src/store/slice/middlewares/local_storage_middleware.ts","../src/store/slice/middlewares/session_storage_middleware.ts","../src/store/slice/implementation.ts","../src/store/storage/implementation.ts","../src/tools/effect/implementation.ts","../src/tools/computed/implementation.ts","../src/tools/selector/implementation.ts","../src/utils/is.ts"],"sourcesContent":["export const LISTENING_PREFIX = 'listening:';\r\n","import { LISTENING_PREFIX } from './constants';\r\nimport { EventEngine, EventEngineDefaults, EventEngineState, Events, ListenOptions } from './types';\r\n\r\nexport function event_engine<E extends Events>(defaults?: EventEngineDefaults) {\r\n  const state: EventEngineState<E> = {};\r\n\r\n  const get = <K extends keyof E>(type: K) => {\r\n    return (state[type] ??= { listeners: [] });\r\n  };\r\n\r\n  function fire<K extends keyof E & string>(type: K, next: E[K]) {\r\n    const subscription = get(type);\r\n    subscription.listeners.forEach((listener) => {\r\n      listener(next, subscription.previous);\r\n    });\r\n    subscription.previous = next;\r\n  }\r\n\r\n  function listen<K extends keyof E & string>(options: ListenOptions<K, E[K], E[K]>) {\r\n    const { type, select, each, once } = options;\r\n    const equal = options.equal ?? defaults?.equal;\r\n\r\n    const subscription = get(type);\r\n\r\n    function clear() {\r\n      const { listeners } = subscription;\r\n\r\n      const index = listeners.indexOf(listener);\r\n      if (index === -1) {\r\n        console.warn('event engine: registered listener not found');\r\n        return;\r\n      }\r\n\r\n      listeners.splice(index, 1);\r\n    }\r\n\r\n    function listener(next: E[K], old: E[K] | undefined) {\r\n      try {\r\n        if (select) {\r\n          next &&= select(next);\r\n          old &&= select(old);\r\n        }\r\n\r\n        if (old && equal?.(next, old)) return;\r\n\r\n        if (each) {\r\n          each(next);\r\n        } else if (once) {\r\n          once(next);\r\n          clear();\r\n        } else {\r\n          console.error('event engine: no listener was provided');\r\n        }\r\n      } catch (error) {\r\n        console.error(error);\r\n      }\r\n    }\r\n\r\n    subscription.listeners.push(listener);\r\n\r\n    if (!type.startsWith(LISTENING_PREFIX)) {\r\n      // @ts-expect-error\r\n      fire(LISTENING_PREFIX + type, listener);\r\n    }\r\n\r\n    return clear;\r\n  }\r\n\r\n  return { fire, listen } as EventEngine<E>;\r\n}\r\n","import { StateEngine } from './types';\r\n\r\nexport function state_engine<T>(): StateEngine<T | undefined>;\r\nexport function state_engine<T>(initial: T): StateEngine<T>;\r\nexport function state_engine<T>(initial?: T) {\r\n  const state = { current: initial, previous: initial };\r\n\r\n  function get(previous?: boolean) {\r\n    return previous ? state.previous : state.current;\r\n  }\r\n\r\n  function set(value: T): void {\r\n    state.previous = state.current;\r\n    state.current = value;\r\n  }\r\n\r\n  return { get, set };\r\n}\r\n","import { is_not_null, is_null, struct, unpack } from '@nagisham/standard';\r\n\r\nimport { event_engine, state_engine } from 'src/engine';\r\n\r\nimport { StoreEvents, WithPrevious } from '../types';\r\nimport { SignalStruct } from './types';\r\n\r\nexport const signal = struct<SignalStruct>(<T>(initial?: T) => {\r\n  const { get, set } = state_engine(initial);\r\n  const { fire, listen } = event_engine<StoreEvents<T | undefined>>();\r\n\r\n  listen({\r\n    type: 'listening:change',\r\n    each: (listener) => {\r\n      is_not_null(get()) && listener(get());\r\n    },\r\n  });\r\n\r\n  listen({\r\n    type: 'cleanup',\r\n    each: () => set(undefined),\r\n  });\r\n\r\n  function accesser(value?: T | WithPrevious<T | undefined>) {\r\n    if (is_null(value)) {\r\n      return get();\r\n    }\r\n\r\n    const old = get();\r\n    const next = unpack(value, old);\r\n\r\n    if (!Object.is(old, next)) {\r\n      set(next);\r\n      fire('change', next);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  return Object.assign(accesser, { fire, listen });\r\n});\r\n","import { is_not_null } from '@nagisham/standard';\r\n\r\nimport { Middleware } from '../types';\r\n\r\nexport function local_storage_middleware(key: string): Middleware {\r\n  return ({ set, listen }) => {\r\n    const initial = localStorage.getItem(key);\r\n\r\n    if (is_not_null(initial)) {\r\n      set(JSON.parse(initial));\r\n    }\r\n\r\n    listen({\r\n      type: 'change',\r\n      each: (next) => {\r\n        localStorage.setItem(key, JSON.stringify(next));\r\n      },\r\n    });\r\n  };\r\n}\r\n","import { is_not_null } from '@nagisham/standard';\r\n\r\nimport { Middleware } from '../types';\r\n\r\nexport function session_storage_middleware(key: string): Middleware {\r\n  return ({ set, listen }) => {\r\n    const initial = sessionStorage.getItem(key);\r\n\r\n    if (is_not_null(initial)) {\r\n      set(JSON.parse(initial));\r\n    }\r\n\r\n    listen({\r\n      type: 'change',\r\n      each: (next) => {\r\n        sessionStorage.setItem(key, JSON.stringify(next));\r\n      },\r\n    });\r\n  };\r\n}\r\n","import {\r\n  is_function,\r\n  is_not_null,\r\n  is_null,\r\n  is_object,\r\n  is_string,\r\n  struct,\r\n  unpack,\r\n} from '@nagisham/standard';\r\n\r\nimport { event_engine, state_engine } from 'src/engine';\r\n\r\nimport { State, StoreEvents, WithPrevious } from '../types';\r\nimport { Middleware, SliceStruct } from './types';\r\n\r\nexport const slice = struct<SliceStruct>(\r\n  <T extends State>(initial?: T, middlewares?: Middleware[]) => {\r\n    const state = state_engine(initial);\r\n    const events = event_engine<StoreEvents<T | undefined>>();\r\n\r\n    events.listen({\r\n      type: 'listening:change',\r\n      each: (listener) => {\r\n        is_not_null(state.get()) && listener(state.get());\r\n      },\r\n    });\r\n\r\n    events.listen({\r\n      type: 'cleanup',\r\n      each: () => state.set(undefined),\r\n    });\r\n\r\n    function copy() {\r\n      return Object.assign({}, state.get());\r\n    }\r\n\r\n    function accesser<K extends keyof T>(\r\n      key_value?: K | Partial<T> | WithPrevious<Partial<T> | undefined>,\r\n      value?: T[K] | WithPrevious<T[K] | undefined>,\r\n    ) {\r\n      if (is_null(key_value) && is_null(value)) {\r\n        return copy();\r\n      }\r\n\r\n      if (is_object(key_value) || is_function(key_value)) {\r\n        const old = state.get();\r\n        const next = Object.assign({}, old, unpack(key_value, old));\r\n\r\n        state.set(next);\r\n        events.fire('change', next);\r\n      }\r\n\r\n      if (is_string(key_value) && is_null(value)) {\r\n        return state.get()?.[key_value];\r\n      }\r\n\r\n      if (is_string(key_value) && is_not_null(value)) {\r\n        const old = state.get();\r\n        const next = Object.assign({}, old, {\r\n          [key_value]: unpack(value, old?.[key_value]),\r\n        });\r\n\r\n        state.set(next);\r\n        events.fire('change', next);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    middlewares?.forEach((middleware) => {\r\n      middleware({ ...state, ...events });\r\n    });\r\n\r\n    return Object.assign(accesser, events);\r\n  },\r\n);\r\n","import {\r\n  Lambda,\r\n  is_array,\r\n  is_function,\r\n  is_not_null,\r\n  is_null,\r\n  is_string,\r\n  struct,\r\n  unpack,\r\n} from '@nagisham/standard';\r\n\r\nimport { event_engine, state_engine } from 'src/engine';\r\n\r\nimport { StoreEvents, WithPrevious } from '../types';\r\nimport { ArrayEvents, StorageStruct } from './types';\r\n\r\nexport const storage = struct<StorageStruct>(<T>(elements?: T[]) => {\r\n  const { get, set } = state_engine(elements ?? []);\r\n  const { fire, listen } = event_engine<StoreEvents<T[]> & ArrayEvents<T | undefined>>();\r\n\r\n  listen({\r\n    type: 'listening:change',\r\n    each: (listener) => {\r\n      get().length && listener(copy());\r\n    },\r\n  });\r\n\r\n  listen({\r\n    type: 'cleanup',\r\n    each: () => set([]),\r\n  });\r\n\r\n  function copy(previous?: boolean) {\r\n    return get(previous).slice();\r\n  }\r\n\r\n  function accesser(\r\n    index_value?: number | string | T[] | WithPrevious<T[]>,\r\n    value?: T | WithPrevious<T | undefined> | undefined,\r\n  ) {\r\n    if (is_null(index_value) && is_null(value)) {\r\n      return copy();\r\n    }\r\n\r\n    if (is_array(index_value) || is_function(index_value)) {\r\n      const next = unpack(index_value, copy());\r\n      set(next);\r\n      fire('change', next);\r\n      return;\r\n    }\r\n\r\n    if (is_not_null(index_value)) {\r\n      const index = is_string(index_value) ? parseInt(index_value) : index_value;\r\n\r\n      if (is_null(value)) {\r\n        return get()[index];\r\n      }\r\n\r\n      const old = get()[index];\r\n      insert(index, unpack(value, old));\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  function find(predicate: Lambda<[T], boolean>) {\r\n    return get().findIndex(predicate);\r\n  }\r\n\r\n  function insert(item: T): void;\r\n  function insert(index: number, item: T): void;\r\n  function insert(index_item: number | T, item?: T) {\r\n    const array = copy();\r\n\r\n    let index: number;\r\n    let element: T;\r\n\r\n    if (is_null(item)) {\r\n      index = array.length;\r\n      element = index_item as T;\r\n    } else {\r\n      index = index_item as number;\r\n      element = item;\r\n    }\r\n\r\n    array.splice(index, 0, element);\r\n\r\n    set(array);\r\n    fire('insert', { index, element });\r\n  }\r\n\r\n  function remove(index: number) {\r\n    const array = copy();\r\n\r\n    const element = array.splice(index, 1)[0];\r\n\r\n    set(array);\r\n    fire('remove', { index, element });\r\n\r\n    return element;\r\n  }\r\n\r\n  function len(): number;\r\n  function len(index: number): void;\r\n  function len(index?: number) {\r\n    const array = get();\r\n\r\n    if (is_null(index)) {\r\n      return array.length;\r\n    }\r\n\r\n    if (index === 0) {\r\n      fire('cleanup');\r\n      return;\r\n    }\r\n\r\n    let i = array.length;\r\n    while (i > index) {\r\n      i--;\r\n      remove(i);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  function each(action: Lambda<[T, number], void>) {\r\n    get().forEach(action);\r\n  }\r\n\r\n  return Object.assign(accesser, {\r\n    find,\r\n    insert,\r\n    remove,\r\n    len,\r\n    each,\r\n    fire,\r\n    listen,\r\n  });\r\n});\r\n","import { Functions, is_function, is_not_null } from '@nagisham/standard';\r\n\r\nimport { Signal } from 'src/store';\r\nimport { ListenOptions } from 'src/engine';\r\n\r\nimport { Cleanup, Effect, EffectOptions } from './types';\r\n\r\nexport const effect: Effect = (options: EffectOptions<Signal[]>): Cleanup => {\r\n  const { listener, dependency } = options;\r\n\r\n  const unsubscribe = new Array<Cleanup>();\r\n  let cleanup: void | Cleanup;\r\n\r\n  const listen_options: ListenOptions<'change', unknown, unknown> = {\r\n    type: 'change',\r\n    each: () => {},\r\n  };\r\n\r\n  dependency.forEach((signal) => {\r\n    listen_options.each = () => {\r\n      if (is_function(cleanup)) {\r\n        cleanup();\r\n        cleanup = undefined;\r\n      }\r\n\r\n      const args = dependency.map(Functions.call);\r\n      if (args.every(is_not_null)) {\r\n        cleanup = listener(...args);\r\n      }\r\n    };\r\n\r\n    unsubscribe.push(signal.listen(listen_options));\r\n  });\r\n\r\n  return () => unsubscribe.forEach(Functions.call);\r\n};\r\n","import { signal } from 'src/store';\r\n\r\nimport { effect } from '../effect';\r\nimport { Computed, ComputedOptions } from './types';\r\n\r\nexport const computed: Computed = <T>(options: ComputedOptions<T, [any]>) => {\r\n  const { listener, dependency } = options;\r\n\r\n  const computed_signal = signal<T>();\r\n\r\n  effect({\r\n    listener: (...args) => {\r\n      computed_signal(listener(...args));\r\n    },\r\n    dependency,\r\n  });\r\n\r\n  return computed_signal;\r\n};\r\n","import { combine } from '@nagisham/standard';\r\n\r\nimport { signal, Signal, Slice } from 'src/store';\r\nimport { State } from 'src/store/types';\r\n\r\nexport function selector<S extends State, T extends S[keyof S]>(\r\n  slice: Slice<S>,\r\n  select: (state: S) => T,\r\n): Signal<T> {\r\n  type K = keyof S & string;\r\n\r\n  const state = {} as { key: K };\r\n\r\n  const proxy = new Proxy(slice(), {\r\n    get: (target, key: K) => {\r\n      state.key = key;\r\n      return Reflect.get(target, key);\r\n    },\r\n  });\r\n\r\n  const selector = signal(select(proxy));\r\n\r\n  selector.listen({\r\n    type: 'cleanup',\r\n    once: combine(\r\n      slice.listen({\r\n        type: 'change',\r\n        select,\r\n        each: (next) => {\r\n          selector(next);\r\n        },\r\n      }),\r\n      selector.listen({\r\n        type: 'change',\r\n        each: (next) => {\r\n          slice(state.key, next);\r\n        },\r\n      }),\r\n    ),\r\n  });\r\n\r\n  return selector;\r\n}\r\n","import { Signal, Slice, State, Storage, signal, slice, storage } from 'src/store';\r\n\r\nexport function is_signal<A, T>(object: A | Signal<T>): object is Signal<T> {\r\n  return object instanceof signal;\r\n}\r\n\r\nexport function is_slice<A, T extends State | undefined>(object: A | Slice<T>): object is Slice<T> {\r\n  return object instanceof slice;\r\n}\r\n\r\nexport function is_storage<A, T>(object: A | Storage<T>): object is Storage<T> {\r\n  return object instanceof storage;\r\n}\r\n"],"names":["LISTENING_PREFIX","event_engine","defaults","state","get","type","fire","next","subscription","listener","listen","options","select","each","once","equal","clear","listeners","index","old","error","state_engine","initial","previous","set","value","signal","struct","is_not_null","accesser","is_null","unpack","local_storage_middleware","key","session_storage_middleware","slice","middlewares","events","copy","key_value","is_object","is_function","is_string","_a","middleware","storage","elements","index_value","is_array","insert","find","predicate","index_item","item","array","element","remove","len","i","action","effect","dependency","unsubscribe","cleanup","listen_options","args","Functions","computed","computed_signal","selector","proxy","target","combine","is_signal","object","is_slice","is_storage"],"mappings":"sHAAaA,EAAmB,aCGzB,SAASC,EAA+BC,EAAgC,CAC7E,MAAMC,EAA6B,CAAA,EAE7BC,EAA0BC,GACtBF,EAAAE,KAAAF,EAAAE,GAAgB,CAAE,UAAW,CAAG,CAAA,GAGjC,SAAAC,EAAiCD,EAASE,EAAY,CACvD,MAAAC,EAAeJ,EAAIC,CAAI,EAChBG,EAAA,UAAU,QAASC,GAAa,CAClCA,EAAAF,EAAMC,EAAa,QAAQ,CAAA,CACrC,EACDA,EAAa,SAAWD,CAC1B,CAEA,SAASG,EAAmCC,EAAuC,CACjF,KAAM,CAAE,KAAAN,EAAM,OAAAO,EAAQ,KAAAC,EAAM,KAAAC,GAASH,EAC/BI,EAAQJ,EAAQ,QAAST,GAAA,YAAAA,EAAU,OAEnCM,EAAeJ,EAAIC,CAAI,EAE7B,SAASW,GAAQ,CACT,KAAA,CAAE,UAAAC,CAAc,EAAAT,EAEhBU,EAAQD,EAAU,QAAQR,CAAQ,EACxC,GAAIS,IAAU,GAAI,CAChB,QAAQ,KAAK,6CAA6C,EAC1D,MACF,CAEUD,EAAA,OAAOC,EAAO,CAAC,CAC3B,CAES,SAAAT,EAASF,EAAYY,EAAuB,CAC/C,GAAA,CAME,GALAP,IACFL,MAASK,EAAOL,CAAI,GACpBY,MAAQP,EAAOO,CAAG,IAGhBA,IAAOJ,GAAA,MAAAA,EAAQR,EAAMY,IAAM,OAE3BN,EACFA,EAAKN,CAAI,EACAO,GACTA,EAAKP,CAAI,EACHS,KAEN,QAAQ,MAAM,wCAAwC,QAEjDI,EAAO,CACd,QAAQ,MAAMA,CAAK,CACrB,CACF,CAEa,OAAAZ,EAAA,UAAU,KAAKC,CAAQ,EAE/BJ,EAAK,WAAWL,CAAgB,GAE9BM,EAAAN,EAAmBK,EAAMI,CAAQ,EAGjCO,CACT,CAEO,MAAA,CAAE,KAAAV,EAAM,OAAAI,EACjB,CCjEO,SAASW,EAAgBC,EAAa,CAC3C,MAAMnB,EAAQ,CAAE,QAASmB,EAAS,SAAUA,CAAQ,EAEpD,SAASlB,EAAImB,EAAoB,CACxB,OAAAA,EAAWpB,EAAM,SAAWA,EAAM,OAC3C,CAEA,SAASqB,EAAIC,EAAgB,CAC3BtB,EAAM,SAAWA,EAAM,QACvBA,EAAM,QAAUsB,CAClB,CAEO,MAAA,CAAE,IAAArB,EAAK,IAAAoB,EAChB,CCVa,MAAAE,EAASC,EAAAA,OAAyBL,GAAgB,CAC7D,KAAM,CAAE,IAAAlB,EAAK,IAAAoB,CAAI,EAAIH,EAAaC,CAAO,EACnC,CAAE,KAAAhB,EAAM,OAAAI,CAAO,EAAIT,EAAyC,EAE3DS,EAAA,CACL,KAAM,mBACN,KAAOD,GAAa,CAClBmB,EAAAA,YAAYxB,EAAK,CAAA,GAAKK,EAASL,EAAK,CAAA,CACtC,CAAA,CACD,EAEMM,EAAA,CACL,KAAM,UACN,KAAM,IAAMc,EAAI,MAAS,CAAA,CAC1B,EAED,SAASK,EAASJ,EAAyC,CACrD,GAAAK,EAAAA,QAAQL,CAAK,EACf,OAAOrB,EAAI,EAGb,MAAMe,EAAMf,IACNG,EAAOwB,EAAAA,OAAON,EAAON,CAAG,EAEzB,OAAO,GAAGA,EAAKZ,CAAI,IACtBiB,EAAIjB,CAAI,EACRD,EAAK,SAAUC,CAAI,EAIvB,CAEA,OAAO,OAAO,OAAOsB,EAAU,CAAE,KAAAvB,EAAM,OAAAI,EAAQ,CACjD,CAAC,ECpCM,SAASsB,EAAyBC,EAAyB,CAChE,MAAO,CAAC,CAAE,IAAAT,EAAK,OAAAd,KAAa,CACpB,MAAAY,EAAU,aAAa,QAAQW,CAAG,EAEpCL,EAAAA,YAAYN,CAAO,GACjBE,EAAA,KAAK,MAAMF,CAAO,CAAC,EAGlBZ,EAAA,CACL,KAAM,SACN,KAAOH,GAAS,CACd,aAAa,QAAQ0B,EAAK,KAAK,UAAU1B,CAAI,CAAC,CAChD,CAAA,CACD,CAAA,CAEL,CCfO,SAAS2B,EAA2BD,EAAyB,CAClE,MAAO,CAAC,CAAE,IAAAT,EAAK,OAAAd,KAAa,CACpB,MAAAY,EAAU,eAAe,QAAQW,CAAG,EAEtCL,EAAAA,YAAYN,CAAO,GACjBE,EAAA,KAAK,MAAMF,CAAO,CAAC,EAGlBZ,EAAA,CACL,KAAM,SACN,KAAOH,GAAS,CACd,eAAe,QAAQ0B,EAAK,KAAK,UAAU1B,CAAI,CAAC,CAClD,CAAA,CACD,CAAA,CAEL,CCJO,MAAM4B,EAAQR,EAAA,OACnB,CAAkBL,EAAac,IAA+B,CACtD,MAAAjC,EAAQkB,EAAaC,CAAO,EAC5Be,EAASpC,IAEfoC,EAAO,OAAO,CACZ,KAAM,mBACN,KAAO5B,GAAa,CAClBmB,EAAA,YAAYzB,EAAM,IAAK,CAAA,GAAKM,EAASN,EAAM,KAAK,CAClD,CAAA,CACD,EAEDkC,EAAO,OAAO,CACZ,KAAM,UACN,KAAM,IAAMlC,EAAM,IAAI,MAAS,CAAA,CAChC,EAED,SAASmC,GAAO,CACd,OAAO,OAAO,OAAO,CAAA,EAAInC,EAAM,IAAK,CAAA,CACtC,CAES,SAAA0B,EACPU,EACAd,EACA,OACA,GAAIK,EAAQ,QAAAS,CAAS,GAAKT,EAAA,QAAQL,CAAK,EACrC,OAAOa,EAAK,EAGd,GAAIE,EAAU,UAAAD,CAAS,GAAKE,EAAA,YAAYF,CAAS,EAAG,CAC5C,MAAApB,EAAMhB,EAAM,MACZI,EAAO,OAAO,OAAO,GAAIY,EAAKY,SAAOQ,EAAWpB,CAAG,CAAC,EAE1DhB,EAAM,IAAII,CAAI,EACP8B,EAAA,KAAK,SAAU9B,CAAI,CAC5B,CAEA,GAAImC,EAAU,UAAAH,CAAS,GAAKT,EAAA,QAAQL,CAAK,EAChC,OAAAkB,EAAAxC,EAAM,QAAN,YAAAwC,EAAcJ,GAGvB,GAAIG,EAAU,UAAAH,CAAS,GAAKX,EAAA,YAAYH,CAAK,EAAG,CACxC,MAAAN,EAAMhB,EAAM,MACZI,EAAO,OAAO,OAAO,CAAA,EAAIY,EAAK,CAClC,CAACoB,CAAS,EAAGR,SAAON,EAAON,GAAA,YAAAA,EAAMoB,EAAU,CAAA,CAC5C,EAEDpC,EAAM,IAAII,CAAI,EACP8B,EAAA,KAAK,SAAU9B,CAAI,CAC5B,CAGF,CAEa,OAAA6B,GAAA,MAAAA,EAAA,QAASQ,GAAe,CACnCA,EAAW,CAAE,GAAGzC,EAAO,GAAGkC,CAAQ,CAAA,CAAA,GAG7B,OAAO,OAAOR,EAAUQ,CAAM,CACvC,CACF,EC3DaQ,EAAUlB,EAAAA,OAA0BmB,GAAmB,CAClE,KAAM,CAAE,IAAA1C,EAAK,IAAAoB,CAAA,EAAQH,EAAayB,GAAY,CAAA,CAAE,EAC1C,CAAE,KAAAxC,EAAM,OAAAI,CAAO,EAAIT,EAA4D,EAE9ES,EAAA,CACL,KAAM,mBACN,KAAOD,GAAa,CAClBL,EAAM,EAAA,QAAUK,EAAS6B,EAAM,CAAA,CACjC,CAAA,CACD,EAEM5B,EAAA,CACL,KAAM,UACN,KAAM,IAAMc,EAAI,EAAE,CAAA,CACnB,EAED,SAASc,EAAKf,EAAoB,CACzB,OAAAnB,EAAImB,CAAQ,EAAE,OACvB,CAES,SAAAM,EACPkB,EACAtB,EACA,CACA,GAAIK,EAAQ,QAAAiB,CAAW,GAAKjB,EAAA,QAAQL,CAAK,EACvC,OAAOa,EAAK,EAGd,GAAIU,EAAS,SAAAD,CAAW,GAAKN,EAAA,YAAYM,CAAW,EAAG,CACrD,MAAMxC,EAAOwB,EAAA,OAAOgB,EAAaT,EAAM,CAAA,EACvCd,EAAIjB,CAAI,EACRD,EAAK,SAAUC,CAAI,EACnB,MACF,CAEI,GAAAqB,EAAAA,YAAYmB,CAAW,EAAG,CAC5B,MAAM7B,EAAQwB,EAAAA,UAAUK,CAAW,EAAI,SAASA,CAAW,EAAIA,EAE3D,GAAAjB,EAAAA,QAAQL,CAAK,EACR,OAAArB,EAAA,EAAMc,CAAK,EAGd,MAAAC,EAAMf,IAAMc,CAAK,EACvB+B,EAAO/B,EAAOa,EAAAA,OAAON,EAAON,CAAG,CAAC,CAClC,CAGF,CAEA,SAAS+B,EAAKC,EAAiC,CACtC,OAAA/C,EAAM,EAAA,UAAU+C,CAAS,CAClC,CAIS,SAAAF,EAAOG,EAAwBC,EAAU,CAChD,MAAMC,EAAQhB,IAEV,IAAApB,EACAqC,EAEAzB,EAAAA,QAAQuB,CAAI,GACdnC,EAAQoC,EAAM,OACJC,EAAAH,IAEFlC,EAAAkC,EACEG,EAAAF,GAGNC,EAAA,OAAOpC,EAAO,EAAGqC,CAAO,EAE9B/B,EAAI8B,CAAK,EACThD,EAAK,SAAU,CAAE,MAAAY,EAAO,QAAAqC,CAAS,CAAA,CACnC,CAEA,SAASC,EAAOtC,EAAe,CAC7B,MAAMoC,EAAQhB,IAERiB,EAAUD,EAAM,OAAOpC,EAAO,CAAC,EAAE,CAAC,EAExC,OAAAM,EAAI8B,CAAK,EACThD,EAAK,SAAU,CAAE,MAAAY,EAAO,QAAAqC,CAAS,CAAA,EAE1BA,CACT,CAIA,SAASE,EAAIvC,EAAgB,CAC3B,MAAMoC,EAAQlD,IAEV,GAAA0B,EAAAA,QAAQZ,CAAK,EACf,OAAOoC,EAAM,OAGf,GAAIpC,IAAU,EAAG,CACfZ,EAAK,SAAS,EACd,MACF,CAEA,IAAIoD,EAAIJ,EAAM,OACd,KAAOI,EAAIxC,GACTwC,IACAF,EAAOE,CAAC,CAIZ,CAEA,SAAS7C,EAAK8C,EAAmC,CAC3CvD,EAAA,EAAE,QAAQuD,CAAM,CACtB,CAEO,OAAA,OAAO,OAAO9B,EAAU,CAC7B,KAAAqB,EACA,OAAAD,EACA,OAAAO,EACA,IAAAC,EACA,KAAA5C,EACA,KAAAP,EACA,OAAAI,CAAA,CACD,CACH,CAAC,ECnIYkD,EAAkBjD,GAA8C,CACrE,KAAA,CAAE,SAAAF,EAAU,WAAAoD,CAAe,EAAAlD,EAE3BmD,EAAc,IAAI,MACpB,IAAAC,EAEJ,MAAMC,EAA4D,CAChE,KAAM,SACN,KAAM,IAAM,CAAC,CAAA,EAGJ,OAAAH,EAAA,QAASnC,GAAW,CAC7BsC,EAAe,KAAO,IAAM,CACtBvB,EAAAA,YAAYsB,CAAO,IACbA,IACEA,EAAA,QAGZ,MAAME,EAAOJ,EAAW,IAAIK,EAAA,UAAU,IAAI,EACtCD,EAAK,MAAMrC,EAAAA,WAAW,IACdmC,EAAAtD,EAAS,GAAGwD,CAAI,EAC5B,EAGFH,EAAY,KAAKpC,EAAO,OAAOsC,CAAc,CAAC,CAAA,CAC/C,EAEM,IAAMF,EAAY,QAAQI,EAAA,UAAU,IAAI,CACjD,EC9BaC,EAAyBxD,GAAuC,CACrE,KAAA,CAAE,SAAAF,EAAU,WAAAoD,CAAe,EAAAlD,EAE3ByD,EAAkB1C,IAEjB,OAAAkC,EAAA,CACL,SAAU,IAAIK,IAAS,CACLG,EAAA3D,EAAS,GAAGwD,CAAI,CAAC,CACnC,EACA,WAAAJ,CAAA,CACD,EAEMO,CACT,ECbgB,SAAAC,EACdlC,EACAvB,EACW,CAGX,MAAMT,EAAQ,CAAA,EAERmE,EAAQ,IAAI,MAAMnC,IAAS,CAC/B,IAAK,CAACoC,EAAQtC,KACZ9B,EAAM,IAAM8B,EACL,QAAQ,IAAIsC,EAAQtC,CAAG,EAChC,CACD,EAEKoC,EAAW3C,EAAOd,EAAO0D,CAAK,CAAC,EAErCD,OAAAA,EAAS,OAAO,CACd,KAAM,UACN,KAAMG,EAAA,QACJrC,EAAM,OAAO,CACX,KAAM,SACN,OAAAvB,EACA,KAAOL,GAAS,CACd8D,EAAS9D,CAAI,CACf,CAAA,CACD,EACD8D,EAAS,OAAO,CACd,KAAM,SACN,KAAO9D,GAAS,CACR4B,EAAAhC,EAAM,IAAKI,CAAI,CACvB,CAAA,CACD,CACH,CAAA,CACD,EAEM8D,CACT,CCxCO,SAASI,EAAgBC,EAA4C,CAC1E,OAAOA,aAAkBhD,CAC3B,CAEO,SAASiD,EAAyCD,EAA0C,CACjG,OAAOA,aAAkBvC,CAC3B,CAEO,SAASyC,EAAiBF,EAA8C,CAC7E,OAAOA,aAAkB7B,CAC3B"}